/**
 *
 * @authors 熊洋 (xywindows@gmail.com)
 * @date    2014-06-23 21:51:16
 * @description 数据实体集合（继承于Array）
 */
var util = require('util'),
  ObjectUtil = require('./ObjectUtil'),
  RecordType = require('./RecordType'),
  arrayProto = Array.prototype,
  proto,
  Entities;

/**
 * 构造函数
 * @param {Array}                 dataArray       数据数组
 * @param {RecordType|Object}     recordType      记录类型
 */
Entities = function(dataArray, /*optinal*/ recordType) {
  var me = this;

  //如果记录类型为空
  //或传入的是配置对象
  if (!recordType || ObjectUtil.isObject(recordType)) {
    recordType = new RecordType(recordType);
  }

  me.keys = {}; //键值
  me.recordType = recordType;
  me.removed = []; //删除的数据

  me.save(dataArray, true);
}

//从Array继承
util.inherits(Entities, Array);

proto = {
  /**
   * 通过ID值获取数据
   * @param  {String}       id            id键值
   */
  getById: function(id) {
    return this.keys[String(id)];
  },

  /**
   * 获取从第start条数据后的limit条数据
   * @param  {int}          start         起始索引
   * @param  {int}          limit         页条数
   */
  take: function(start, limit) {
    var me = this

    return start != null && limit != null ? me.slice.call(me, start, start + limit) : me;
  },

  /**
   * 将数据保存到集合中
   * 如果数据为幽灵状态-》新增
   * 如果数据已存在-》更新
   */
  save: function(entities, /*private*/ internal) {
    var me = this,
      recordType = me.recordType;

    entities = ObjectUtil.isArray(entities) ?
      entities :
      arrayProto.slice.call(arguments, 0);


    entities.forEach(function(item, index) {
      var id, orgItem;

      if (!item) {
        return;
      }

      //幽灵状态
      if (recordType.isPhantom(item) || internal) {

        id = recordType.id(item);
        //添加ID值 并缓存到键值
        me.keys[id] = item;
        //添加到集合中
        arrayProto.push.call(me, item);

      } else { //如果已存在ID 确定其唯一性

        id = recordType.id(item);
        //获取原始数据
        if (orgItem = me.keys[id]) { //如果存在原始记录 
          //深度克隆记录
          ObjectUtil.extend(true, orgItem, item);
          entities.slice(index, 1, orgItem); //替换
        } else { //没有原始记录 无视之
          entities.slice(index, 1); //删除
        }
      }

    });

    return entities;
  },

  /**
   * 查询
   *
   * ps：操蛋，貌似nodejs没有实现ECMA5中的filter
   *
   * @param  {Function}         condition        过滤函数
   */
  find: function(condition) {
    var me = this,
      ret;

    if (!condition) {
      return me;
    }

    ret = [];
    me.forEach(function(item, index) {
      if (condition(item, index, me.recordType) === true) {
        ret.push(item);
      }
    });

    return me.newSelf(ret);
  },

  /**
   * 排序
   * @param  {Function}         iterator        排序函数
   
  sort: function(iterator) {
    var me = this,
      ret;

    if (!iterator) {
      ret = me;
    } else {
      ret = arrayProto.sort.call(me, iterator);
    }

    return ret;
  },
  */
  /**
   * 删除
   * @param  {Object||Array}     entities    需要删除的数据
   */
  remove: function(entities) {
    var me = this,
      recordType = me.recordType,
      removed = [];

    entities = ObjectUtil.isArray(entities) ?
      entities :
      arrayProto.slice.call(arguments, 0);

    //迭代需要删除的数据
    entities.forEach(function(item) {
      var id = recordType.getId(item);

      if (item = me.keys[id]) {
        //从删除键值
        delete me.keys[id];
        //删除
        arrayProto.splice.call(me, me.indexOf(item), 1);
        removed.push(item);

        //放入到已删除的数据中
        if (me.removed.indexOf() === -1) {
          me.removed.push(item);
        }
      }
    });

    return removed;
  },

  /**
   * 删除符合条件的数据
   * @param  {Function}     condition      筛选函数
   */
  removeAll: function(condition) {
    var me = this,
      recordType = me.recordType,
      i = 0,
      len = me.length,
      removed = [],
      item;

    for (; i < len; i++) {
      item = me[i];

      if (condition(item, i, me) === true) {

        removed.push(item);
        //从删除键值
        delete me.keys[recordType.getId(item)];
        //删除
        arrayProto.splice.call(me, i, 1);
        //放入删除的数组中
        if (me.removed.indexOf(item) === -1) {
          me.removed.push(item);
        }

        i--;
        len--;
      }
    }

    return removed;
  },

  /**
   * 恢复删除的数据
   * @param  {Array}        idArray         id数组
   */
  recycle: function(idArray) {
    var me = this,
      entities = [],
      removed = me.removed,
      i, len, item;

    //通通toString
    idArray = idArray.map(String);

    for (i = 0, len = removed.length; i < len; i++) {
      var id;

      item = removed[i];
      id = String(me.recordType.getId(item));

      //如果在删除的记录中
      if (idArray.indexOf(id) !== -1) {
        entities.push(item);
        //从删除缓存中剔除
        removed.splice(i, 1);

        i--;
        len--;
      }
    }

    return me.save(entities, true);
  },

  newSelf: function(data) {
    var me = this;
    return new Entities(data, me.recordType);
  },

  /**
   * 转换为数组
   */
  toArray: function() {
    return arrayProto.slice.call(this, 0);
  }
};

proto.add = proto.save;


['push', 'unshift', 'pop', 'shift', 'splice', 'concat'].forEach(function(method) {
  proto[method] = noop;
});


['slice'].forEach(function(method) {
  proto[method] = (function(method) {
    return function() {
      var me = this;
      return me.newSelf(arrayProto[method].apply(me, arguments));
    }
  })(method);
})

function noop() {}


ObjectUtil.extend(Entities.prototype, proto);

module.exports = Entities;