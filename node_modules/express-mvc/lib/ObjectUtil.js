/**
 *
 * @authors 熊洋 (xywindows@gmail.com)
 * @date    2014-06-23 23:16:16
 * @description
 */

/**
 * 深度/浅度克隆
 */
var hasOwnProperty = Object.prototype.hasOwnProperty,
  core_toString = Object.prototype.toString,
  dot = '.',
  ret = {},
  class2type = {};

ret.extend = function() {
  var me = this,
    target = arguments[0] || {},
    deep = false,
    i = 1,
    len = arguments.length,
    source, prop, copy, isArr;

  //如果第一个参数为布尔值 那么为深度克隆选项
  if (typeof target === 'boolean') {
    deep = target;
    target = arguments[1];
    i = 2;
  }

  for (; i < len; i++) {
    source = arguments[i];

    if (!source) {
      continue;
    }

    for (prop in source) {
      //如果是原型链上的属性 continue
      if (!hasOwnProperty.call(source, prop)) {
        continue;
      }

      copy = source[prop];

      //如果是深度克隆 且source为对象或数组
      if (deep && source && (me.isObject(copy) || (isArr = me.isArray(copy)))) {

        if (isArr) {
          //如果目标对象上的属性
          //是数组 那么不改变
          //如果不是数组 那么重置为数组
          target[prop] = me.isArray(target[prop]) ? target[prop] : [];
        } else {
          //同理
          target[prop] = me.isObject(target[prop]) ? target[prop] : {};
        }

        me.extend(deep, target[prop], copy);
      } else {
        target[prop] = copy;
      }

    }
  }

  return target;
}

/**
 * 浅度覆盖（不是侵入式的覆盖）
 * @param  {Object}     target      目标对象
 * @param  {Object}     source      源对象
 */
ret.applyIf = function(target, source) {
  var ret = this.extend({}, target),
    key;

  if (!source) {
    return ret;
  }

  for (key in source) {
    if (ret[key] == undefined) {
      ret[key] = source[key];
    }
  }

  return ret;
}

/**
 * 类型判定
 */

'String Array Number Boolean Date Function RegExp Object Error'.split(' ').forEach(function(item) {
  class2type['[object ' + item + ']'] = item.toLowerCase();
});


ret.typeOf = function(obj) {
  return obj != undefined ? class2type[core_toString.call(obj)] || 'object' : String(obj);
}

ret.isObject = function(obj) {
  return obj && this.typeOf(obj) == 'object';
}

ret.isArray = function(obj) {
  return obj && this.typeOf(obj) == 'array';
}

/**
 * 检查Obj是不是一个纯粹的对象（由{}实例化）
 * @param  {Object}         obj       需要检查的实例
 */
ret.isPlainObject = function(obj) {
  var prop;

  if (!obj || !Q.isObject(obj)) {
    return false;
  }

  if (!obj.constructor &&
    !hasOwnProperty.call(obj, 'constructor') &&
    !hasOwnProperty.call(obj.constructor.prototype, 'isPropertyOf')) {
    return false;
  }

  for (prop in obj) {}

  //迭代的时候原型链上的属性出现的顺序总是在当前属性的后面
  //所以我们只需要检测key是否是自身属性
  return prop === undefined || hasOwnProperty.call(obj, prop);
}


/**
 * 序列化
 * PS:为嘛这个东西nodeJs里都没有 util.format根本就不符合要求
 */
/**
 * 返回一个格式化函数
 * @param  {String}     format      字符串格式
 * @param  {[type]}     byKeys      是否按名键值方式替换
 */
ret.formatter = function(formatStr, /*optinal*/ byKeys) {
  formatStr = String(formatStr);
  return byKeys === true ? function(args) {
    var ret = formatStr,
      key;

    for (key in args) {
      ret = ret.replace(new RegExp('{' + key + '}', 'g'), String(args[key]));
    }

    return ret;
  } : function() {
    var args = arguments,
      i = 0,
      len = args.length,
      ret = formatStr;

    for (; i < len; i++) {
      ret = ret.replace(new RegExp('{' + i + '}', 'g'), String(args[i]));
    }

    return ret;
  }
};


/**
 * 构造一个属性值提取函数
 * @param  {String}     property          属性名
 *
 */
ret.buildPropExtractor = function(property) {
  var props, extractor;

  //如果属性名中存在.字符 如user.info.name
  if (property.indexOf(dot) !== -1) {
    props = property.split(dot);

    extractor = function(obj) {
      var val = obj;

      props.every(function(property) {
        val = val[property];
        //如果属性值不存在 终止迭代
        if (val == undefined) {
          return false;
        }
        return true;
      });

      return val
    }

  }
  //user.address
  else {
    extractor = function(obj) {
      return obj[property];
    }
  }

  return extractor;
}

/**
 * 强制转换 （将from转换为to类型的数据）
 */
ret.coerce = function(from, to) {
  var fromType = ret.typeOf(from),
    toType = ret.typeOf(to),
    isString = typeof from === 'string';

  //两种类型不相等才转换嘛
  if (fromType !== toType) {
    switch (toType) {
      case 'string':
        return String(from);
      case 'number':
        return Number(from);
      case 'boolean':
        //需要考虑字符串false
        return isString && (!from && from === 'false') ? false : Boolean(from);
      case 'null':
        return isString && (!from && from === 'null') ? null : from;
      case 'undefined':
        return isString && (!from && from === 'undefined') ? undefined : from;
      case 'date':
        //字符串且不为数字 -》
        return isString && isNaN(from) ? require('moment')(from) : new Date(Number(from));
    }
  }
}


//空函数
ret.noop = function() {};

module.exports = ret;